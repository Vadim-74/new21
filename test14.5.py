

# def linear_solve(a, b):
#     if a:
#         return b / a
#     elif not a and not b:  # снова используем числа в логических выражениях
#         return "Бесконечное количество корней"
#     else:
#         return "Нет корней"
# print(linear_solve(0, 0))

# a*x**2 + b*x + c = 0 - общий вид уравнения
# D = b**2 - 4*a*c - дискриминант
# Если D<0, то уравнение не имеет вещественных корней
# Если D=0, то уравнение имеет один корень - x = -b/(2*a)
# Если D>0, то уравнение имеет два корня
# x1 = (-b - D**0.5)/(2*a)
# x2 = (-b + D**0.5)/(2*a)
#
# P.S. D**0.5 - равносильно извлечению квадратного корня

# def D(a,b,c):
#     return b**2 - 4*a*c
#
# def quadratic_solve(a,b,c):
#     if D(a,b,c) < 0:
#         return "Нет вещественных корней"
#     elif D(a, b, c) == 0:
#         return -b / (2 * a)
#     else:
#         return (-b-D(a,b,c)**0.5)/(2*a), (-b+D(a,b,c)**0.5)/(2*a)
#
# M = {'a' : 1,
#      'b' : 0,
#      'c' : -1}
#
# print(quadratic_solve(*dict.values(M)))



# myFile = open(r'\C:\Users\Админ\Desktop\test\filename.txt') # 15.2.2
# print(list(map(len, a))) # 14.6.3
# list(map(len, a)) # 14.6.5
# list(map(str.upper, a)) # 14.6.6
# print(next(str_iter))  # m


# Напишите рекурсивную функцию, находящую
# минимальный элемент списка без использование циклов и встроенной функции min().
# def min_list(L):
#     if len(L) == 1:
#         return L[0]
#     return L[0] if L[0] < min_list(L[1:]) else min_list(L[1:])


# Напишите рекурсивную функцию, которая зеркально разворачивает
# число. Предполагается, что число не содержит нули.
# def mirror(a, res=0):
#     if a == 0:
#         return res
#     else:
#         return mirror(a // 10, res * 10 + a % 10)


# Поработаем над более сложной рекурсивной функцией. Сейчас попробуем
# реализовать функцию equal(N, S), проверяющую, совпадает ли сумма
# цифр числа N с числом S. При написании программы следует обратить внимание на то, что,
# если S стала отрицательной, то необходимо сразу вернуть False.
# def equal(N, S):
#     if S < 0:
#         return False
#     if N < 10:
#         return N == S
#     else:
#         return equal(N // 10, S - N % 10)


# # Теперь попробуем написать генератор для приближенного
# # вычисления числа e = 2.718. Для нахождения числа, удовлетворяющего
# # необходимой точности будем использовать следующий цикл:
# last = 0
# for a in e(): # e() - генератор
#     if (a - last) < 0.00000001: # ограничение на точность
#         print(a)
#         break # после достижения которого - завершаем цикл
#     else:
#         last = a # иначе - присваиваем новое значение
# #Для вычисления числа e с определенной точностью можно использовать формулу:
# e_n = (1 + 1/n)**n

# Реализуйте функцию-генератор, каждое
# значение которого — приближение числа e с некоторым числом n.
# def e():
#     n = 1
#
#     while True:
#         yield (1 + 1 / n) ** n
#         n += 1

# Попробуем написать декоратор, который позволяет вызвать функцию,
# только если она вызывается авторизованным пользователем.
# yesno = input("""Введите Y, если хотите авторизоваться или N,
#              если хотите продолжить работу как анонимный пользователь: """)
#
# auth = yesno == "Y"
#
# def is_auth(func):
#     def wrapper():
#         if auth:
#             print("Пользователь авторизован")
#             func()
#         else:
#             print("Пользователь неавторизован. Функция выполнена не будет")
#     return wrapper
#
# @is_auth
# def from_db():
#     print("some data from database")
#
# from_db()
#
# # Если в нашу программу хотим добавить еще одну функцию, для
# # которой мы бы хотели сначала проверить авторизацию
# # пользователя, достаточно всего лишь указать для нее декоратор.
# @is_auth
# def change_profile():
#     print("Profile has been changed")


# Реализуйте функцию-декоратор, которая проверяет доступ к функции по
# username пользователя. Все username пользователей хранятся в глобальной
# области видимости в списке USERS. При согласии пользователя на авторизацию
# ему предлагается ввести username, который также хранится в глобальной области
# видимости. Функция должна использовать два декоратора: один для проверки
# авторизации вообще (реализован выше), второй — для проверки доступа.
# USERS = ['admin', 'guest', 'director', 'root', 'superstar']
#
# yesno = input("""Введите Y, если хотите авторизоваться или N,
#              если хотите продолжить работу как анонимный пользователь: """)
#
# auth = yesno == "Y"
#
# if auth:
#     username = input("Введите ваш username:")
#
# @is_auth
# @has_access
# def from_db():
#     print("some data from database")
#
# from_db()
#
# Ответ
# def has_access(func):
#     def wrapper():
#         if username in USERS:
#             print("Авторизован как", username)
#             func()
#         else:
#             print("Доступ пользователю", username, "запрещен")
#     return wrapper

